# 그래프 이론

### 용어

- 정점(Vertex) : 어떠한 곳이나 어떠한 사람
- 간선(Edge) : 무언가로 간다

- 단방향 간선 : 한쪽으로만 갈 수 있는 것
- 양방향 간선 : 양쪽 다 갈 수 있는 것

- 정점으로 나가는 간선을 해당 정점의 outdegree
- 정점으로 들어오는 간선을 해당 정점의 indegree

- 그래프(Graph) : 정점과 간선들로 이루어진 집합

<br>

# 트리(Tree)

트리는 그래프 이론에서 사이클이 없는 무방향 그래프 또는 사이클이 없는 방향 그래프인 DAG(Directed Acyclic Graph)를 지칭함

- 부모, 자식 계층 구조를 가짐
- V - 1 = E 라는 특징이 있음
  - 간선의 수는 노드 수 - 1 이라는 특징
- 임의의 두 노드 사이의 경로는 "유일무이"하며 "존재"함.
  - 즉, 트리 내의 어떤 노드와 어떤 노드까지 갈 수 있음

### 용어

- 루트노드 : 가장 위에 있는 노드
  - 보통 트리문제가 나오고, 트리 탐색 시 루트노드를 중심으로 탐색하면 문제가 쉽게 풀리는 경우가 많음
- 내부노드 : 루프노드와 내부노드 사이에 있는 노드
- 리프노드 : 자식노드가 없는 노드
- 서브트리 : 트리내의 하위 집합을 의미함. 트리내에 있는 부분집합이라고도 볼 수 있음.
- 이진트리 : 자식의 노드 수가 2개 이하인 트리를 의미함
  - 정이진트리(full binary tree) : 자식노드가 0 또는 2개인 이진트리
  - 완전이진트리(complete binary tree) : 왼쪽에서부터 채워져있는 이진트리
  - 변질이진트리(degenerate binary tree) : 자식노드가 하나밖에 없는 이진트리
  - 포화이진트리(perfect binary tree) : 모든 노드가 꽉차있는 이진트리
  - 균형이진트리(balanced binary tree) : 왼쪽과 오른쪽의 노드의 높이차가 1이하인 이진트리
    - map, set을 구성하는 red-black tree는 균형이진트리 중 하나
- 이진탐색트리 : 노드의 오른쪽 하위 트리에는 "노드의 값보다 큰 값"이 있는 노드만 포함되고, 왼쪽 하위트리에는 "노드의 값보다 작은값"이 들어있는 트리
  - 탐색(검색)에 용이
- 숲(forest) : 트리로 이루어진 집합
- DAG : 방향성이 있고 사이클이 없는 그래프
- 연결된 컴포넌트(connected component) : 연결되어있는 정점과 간선의 집합
  - 연결되어있는지 아니면 연결되어있지 않은지를 토대로 연결된 컴포넌트로 나눈다. 이런 컴포넌트들을 번호를 붙여가며 색칠하는 알고리즘은 풀르드필(floodfill)이다.

<br>

# 그래프 표현방법

컴퓨터에게 이러한 그래프를 그렸다고 알려줄 표현방법으로는 인접행렬과 인접리스트가 있다.

### 인접행렬

- 그래프에서 정점과 간섬의 관계를 나타내는 정사각형 행렬을 의미함
- 보통 boolean 2차원 행렬을 사용
- 시간복잡도 O(V^2), 공간복잡도 O(V^2)
  - V는 정점(Vertex)를 의미하고, E는 간선(Edge)를 의미함

```cpp
bool a[10][10];
for(int i = 0; i < V; i++) {
  for(int j = 0; j < V; j++) {
    if(a[i][j])
      cout << i << "부터 " << j << "까지 경로가 있습니다.\n";
  }
}
```

e.g. a[10][10]이 정의됐다면 a[1][3]=1의 뜻은 1로부터 3까지 가는 경로가 있다는 의미이고, a[1][2]=0이라면 1로부터 2까지 가는 경로가 없다는 것을 의미함

### 인접리스트(adjacency list)

- 정점에서 정점을 연결하는 것을 하나의 연결 리스트를 통해 표현하는 것을 의미함
- 보통 벡터(vector) 여러개를 이용해서 인접한 노드들을 그 벡터에 담음.
- 시간복잡도 O(V + E), 공간복잡도 O(V + E)

```cpp
vector<int> adj[10];
adj[1].push_back(2);
for(int i = 0; i < V; i++) {
  // 첫 번째 표현방법 - foreach문
  for(int there : adj[i]) {
    ...
  }

  // 두 번재 표현방법 - for문
  for(int j = 0; j < adj[i].size(); j++) {
    int there = adj[i][j];
  }
}
// 첫 번째와 두 번째 표현방법의 코드는 의미가 같음
```

e.g. vector<int> adj[10]이 정의됐다면 adj[1].push_back(2)는 1번 노드로부터 2번 노드로 갈 수 있음을 의미함

> 보통 인접리스트로 할 생각을 하고, 문제에서 인접행렬이 주어졌으면 인접행렬로 푸는 것이 좋음

<br>

### DFS(Depth-First Search), 깊이우선탐색

- 가장 멀리있는(깊이있는) 노드를 먼저 탐색하는 알고리즘
- 메모리를 덜 씀
- 완전탐색의 경우에 많이 씀

### BFS(Breadth-First Search), 너비우선탐색

- 루트 또는 임의의 노드에서 시작해서 인접한 노드를 먼저 탐색하는 알고리즘
- 메모리를 더 씀
- 가중치가 같은 그래프내에서 최단거리를 구할 수 있음

<br>

# 트리순회

이진트리내에서 트리를 순회하는 알고리즘

### 후위순회(postorder traversal)

- 자식들 노드를 방문하고 자신의 노드를 방문

### 전위순회(preorder traversal)

- 자신의 노드를 방문하고 그 다음 노드들을 방문

### 중위순회(inorder traversal)

- 왼쪽 노드를 먼저 방문하고, 그 다음 자신의 노드를 방문하고, 그 다음 오른쪽 노드 방문함

### 레벨순회(level traversal)

- BFS와 동일함
